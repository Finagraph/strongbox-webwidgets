/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming



/** Models an account listed in a Chart Of Accounts. */
export class Account implements IAccount {
    /** A set of classifications for the account used for financial analysis. */
    classification!: AccountClassification[];
    /** A description of the account. */
    description?: string | undefined;
    /** An identifier for the account, unique within the scope of the Chart Of Accounts associated with this account. */
    id!: string;
    kind!: AccountKind;
    /** A friendly name for the account. */
    name!: string;
    role!: ChartOfAccountsRole;
    /** A hierarchical representation of any sub-accounts that are associated with this account. Sub-accounts are used to organize the Chart of Accounts for reporting purposes and may manifest themselves as subtotals in the presentaton of Financial Statements. */
    subaccounts!: Account[];
    /** A human-friendly alpha-numeric code or number as originally assigned to the account by the bookkeeper. If provided, this value may be helpful for classification, sorting, or as a secondary identifier for the account. */
    userAssignedCode?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.classification = [];
            this.subaccounts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["classification"])) {
                this.classification = [] as any;
                for (let item of _data["classification"])
                    this.classification!.push(AccountClassification.fromJS(item));
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.kind = _data["kind"];
            this.name = _data["name"];
            this.role = _data["role"];
            if (Array.isArray(_data["subaccounts"])) {
                this.subaccounts = [] as any;
                for (let item of _data["subaccounts"])
                    this.subaccounts!.push(Account.fromJS(item));
            }
            this.userAssignedCode = _data["userAssignedCode"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.classification)) {
            data["classification"] = [];
            for (let item of this.classification)
                data["classification"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["kind"] = this.kind;
        data["name"] = this.name;
        data["role"] = this.role;
        if (Array.isArray(this.subaccounts)) {
            data["subaccounts"] = [];
            for (let item of this.subaccounts)
                data["subaccounts"].push(item.toJSON());
        }
        data["userAssignedCode"] = this.userAssignedCode;
        return data; 
    }

    clone(): Account {
        const json = this.toJSON();
        let result = new Account();
        result.init(json);
        return result;
    }
}

/** Models an account listed in a Chart Of Accounts. */
export interface IAccount {
    /** A set of classifications for the account used for financial analysis. */
    classification: AccountClassification[];
    /** A description of the account. */
    description?: string | undefined;
    /** An identifier for the account, unique within the scope of the Chart Of Accounts associated with this account. */
    id: string;
    kind: AccountKind;
    /** A friendly name for the account. */
    name: string;
    role: ChartOfAccountsRole;
    /** A hierarchical representation of any sub-accounts that are associated with this account. Sub-accounts are used to organize the Chart of Accounts for reporting purposes and may manifest themselves as subtotals in the presentaton of Financial Statements. */
    subaccounts: Account[];
    /** A human-friendly alpha-numeric code or number as originally assigned to the account by the bookkeeper. If provided, this value may be helpful for classification, sorting, or as a secondary identifier for the account. */
    userAssignedCode?: string | undefined;
}

/** Models a classification for an account. */
export class AccountClassification implements IAccountClassification {
    /** An identifier for the account classification within the scope of the associated taxonomy. */
    classificationId!: string;
    /** The taxonomy in which the account classification is defined. */
    taxonomyId!: string;

    constructor(data?: IAccountClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.classificationId = _data["classificationId"];
            this.taxonomyId = _data["taxonomyId"];
        }
    }

    static fromJS(data: any): AccountClassification {
        data = typeof data === 'object' ? data : {};
        let result = new AccountClassification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classificationId"] = this.classificationId;
        data["taxonomyId"] = this.taxonomyId;
        return data; 
    }

    clone(): AccountClassification {
        const json = this.toJSON();
        let result = new AccountClassification();
        result.init(json);
        return result;
    }
}

/** Models a classification for an account. */
export interface IAccountClassification {
    /** An identifier for the account classification within the scope of the associated taxonomy. */
    classificationId: string;
    /** The taxonomy in which the account classification is defined. */
    taxonomyId: string;
}

/** Models the organization for which accounting and other financial data was prepared. */
export class AccountingEntity implements IAccountingEntity {
    accountingMethod!: AccountingMethod;
    baseCurrency?: Currency;
    fiscalYearEnd?: YearEnd;
    homeCountry?: Country;
    taxYearEnd?: YearEnd;
    /** A list of addresses. */
    addresses!: Address[];
    /** A list of emails. */
    emails!: EmailAddress[];
    /** A list of identifiers. */
    identifiers!: Identifier[];
    /** A list of names. */
    names!: OrganizationName[];
    /** A list of other contact methods. */
    otherContactMethods!: OtherContactMethod[];
    /** A list of phone numbers. */
    phoneNumbers!: PhoneNumber[];
    /** A list of websites. */
    websites!: Website[];

    constructor(data?: IAccountingEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.addresses = [];
            this.emails = [];
            this.identifiers = [];
            this.names = [];
            this.otherContactMethods = [];
            this.phoneNumbers = [];
            this.websites = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountingMethod = _data["accountingMethod"];
            this.baseCurrency = _data["baseCurrency"] ? Currency.fromJS(_data["baseCurrency"]) : <any>undefined;
            this.fiscalYearEnd = _data["fiscalYearEnd"] ? YearEnd.fromJS(_data["fiscalYearEnd"]) : <any>undefined;
            this.homeCountry = _data["homeCountry"] ? Country.fromJS(_data["homeCountry"]) : <any>undefined;
            this.taxYearEnd = _data["taxYearEnd"] ? YearEnd.fromJS(_data["taxYearEnd"]) : <any>undefined;
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(Address.fromJS(item));
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(EmailAddress.fromJS(item));
            }
            if (Array.isArray(_data["identifiers"])) {
                this.identifiers = [] as any;
                for (let item of _data["identifiers"])
                    this.identifiers!.push(Identifier.fromJS(item));
            }
            if (Array.isArray(_data["names"])) {
                this.names = [] as any;
                for (let item of _data["names"])
                    this.names!.push(OrganizationName.fromJS(item));
            }
            if (Array.isArray(_data["otherContactMethods"])) {
                this.otherContactMethods = [] as any;
                for (let item of _data["otherContactMethods"])
                    this.otherContactMethods!.push(OtherContactMethod.fromJS(item));
            }
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(PhoneNumber.fromJS(item));
            }
            if (Array.isArray(_data["websites"])) {
                this.websites = [] as any;
                for (let item of _data["websites"])
                    this.websites!.push(Website.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountingEntity {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingMethod"] = this.accountingMethod;
        data["baseCurrency"] = this.baseCurrency ? this.baseCurrency.toJSON() : <any>undefined;
        data["fiscalYearEnd"] = this.fiscalYearEnd ? this.fiscalYearEnd.toJSON() : <any>undefined;
        data["homeCountry"] = this.homeCountry ? this.homeCountry.toJSON() : <any>undefined;
        data["taxYearEnd"] = this.taxYearEnd ? this.taxYearEnd.toJSON() : <any>undefined;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item.toJSON());
        }
        if (Array.isArray(this.identifiers)) {
            data["identifiers"] = [];
            for (let item of this.identifiers)
                data["identifiers"].push(item.toJSON());
        }
        if (Array.isArray(this.names)) {
            data["names"] = [];
            for (let item of this.names)
                data["names"].push(item.toJSON());
        }
        if (Array.isArray(this.otherContactMethods)) {
            data["otherContactMethods"] = [];
            for (let item of this.otherContactMethods)
                data["otherContactMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (Array.isArray(this.websites)) {
            data["websites"] = [];
            for (let item of this.websites)
                data["websites"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AccountingEntity {
        const json = this.toJSON();
        let result = new AccountingEntity();
        result.init(json);
        return result;
    }
}

/** Models the organization for which accounting and other financial data was prepared. */
export interface IAccountingEntity {
    accountingMethod: AccountingMethod;
    baseCurrency?: Currency;
    fiscalYearEnd?: YearEnd;
    homeCountry?: Country;
    taxYearEnd?: YearEnd;
    /** A list of addresses. */
    addresses: Address[];
    /** A list of emails. */
    emails: EmailAddress[];
    /** A list of identifiers. */
    identifiers: Identifier[];
    /** A list of names. */
    names: OrganizationName[];
    /** A list of other contact methods. */
    otherContactMethods: OtherContactMethod[];
    /** A list of phone numbers. */
    phoneNumbers: PhoneNumber[];
    /** A list of websites. */
    websites: Website[];
}

/** Models options for importing accounting data. */
export class AccountingImportOptions implements IAccountingImportOptions {
    /** Used to specify privacy controls to be applied to the imported financial data. */
    privacyControls!: PrivacyControl[];
    transactions!: TransactionImportOptions;
    financialStatements!: FinancialStatementImportOptions;

    constructor(data?: IAccountingImportOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.privacyControls = [];
            this.transactions = new TransactionImportOptions();
            this.financialStatements = new FinancialStatementImportOptions();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["privacyControls"])) {
                this.privacyControls = [] as any;
                for (let item of _data["privacyControls"])
                    this.privacyControls!.push(item);
            }
            this.transactions = _data["transactions"] ? TransactionImportOptions.fromJS(_data["transactions"]) : new TransactionImportOptions();
            this.financialStatements = _data["financialStatements"] ? FinancialStatementImportOptions.fromJS(_data["financialStatements"]) : new FinancialStatementImportOptions();
        }
    }

    static fromJS(data: any): AccountingImportOptions {
        data = typeof data === 'object' ? data : {};
        let result = new AccountingImportOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.privacyControls)) {
            data["privacyControls"] = [];
            for (let item of this.privacyControls)
                data["privacyControls"].push(item);
        }
        data["transactions"] = this.transactions ? this.transactions.toJSON() : <any>undefined;
        data["financialStatements"] = this.financialStatements ? this.financialStatements.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AccountingImportOptions {
        const json = this.toJSON();
        let result = new AccountingImportOptions();
        result.init(json);
        return result;
    }
}

/** Models options for importing accounting data. */
export interface IAccountingImportOptions {
    /** Used to specify privacy controls to be applied to the imported financial data. */
    privacyControls: PrivacyControl[];
    transactions: TransactionImportOptions;
    financialStatements: FinancialStatementImportOptions;
}

/** Defines possible values for accounting methods (aka the basis of accounting). |Enum Value|Description| |--|--| |Unknown|The accounting method is not known.| |Accrual|Income and expenses are recorded when earned, which does not necessarily align with<br/>            when cash is actually received or paid. Creditors and debtors are typically tracked via AR and AP accounts.| |Cash|Income and expenses are recorded when cash is actually received.| |ModifiedCash|Income is recorded when it is earned, but expenses are recorded only when money is paid out.| */
export type AccountingMethod = "Unknown" | "Accrual" | "Cash" | "ModifiedCash";

/** The kind of an account can be either real or nominal. |Enum Value|Description| |--|--| |Real|Real or permanent account balances carry over to the next fiscal year. This includes Asset, Liability, and Equity accounts.| |Nominal|Nominal accounts are reset at the end of each fiscal year. This includes Revenue and Expense accounts.| */
export type AccountKind = "Real" | "Nominal";

/** A reference to an account for which full details can be found in the Chart Of Accounts. */
export class AccountReference implements IAccountReference {
    /** An identifier for an account in the Chart Of Accounts. */
    accountId!: string;

    constructor(data?: IAccountReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): AccountReference {
        data = typeof data === 'object' ? data : {};
        let result = new AccountReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        return data; 
    }

    clone(): AccountReference {
        const json = this.toJSON();
        let result = new AccountReference();
        result.init(json);
        return result;
    }
}

/** A reference to an account for which full details can be found in the Chart Of Accounts. */
export interface IAccountReference {
    /** An identifier for an account in the Chart Of Accounts. */
    accountId: string;
}

/** Models the starting, ending, and total change in account balance for a specific account. */
export class AccountSummary implements IAccountSummary {
    /** An identifier for the account. */
    accountId!: string;
    endingBalance!: DoubleEntryAmount;
    netChange!: DoubleEntryAmount;
    startingBalance!: DoubleEntryAmount;

    constructor(data?: IAccountSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.endingBalance = new DoubleEntryAmount();
            this.netChange = new DoubleEntryAmount();
            this.startingBalance = new DoubleEntryAmount();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.endingBalance = _data["endingBalance"] ? DoubleEntryAmount.fromJS(_data["endingBalance"]) : new DoubleEntryAmount();
            this.netChange = _data["netChange"] ? DoubleEntryAmount.fromJS(_data["netChange"]) : new DoubleEntryAmount();
            this.startingBalance = _data["startingBalance"] ? DoubleEntryAmount.fromJS(_data["startingBalance"]) : new DoubleEntryAmount();
        }
    }

    static fromJS(data: any): AccountSummary {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["endingBalance"] = this.endingBalance ? this.endingBalance.toJSON() : <any>undefined;
        data["netChange"] = this.netChange ? this.netChange.toJSON() : <any>undefined;
        data["startingBalance"] = this.startingBalance ? this.startingBalance.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AccountSummary {
        const json = this.toJSON();
        let result = new AccountSummary();
        result.init(json);
        return result;
    }
}

/** Models the starting, ending, and total change in account balance for a specific account. */
export interface IAccountSummary {
    /** An identifier for the account. */
    accountId: string;
    endingBalance: DoubleEntryAmount;
    netChange: DoubleEntryAmount;
    startingBalance: DoubleEntryAmount;
}

/** Account Totals model the starting, ending, and total change in account balance by reporting period. */
export class AccountTotals implements IAccountTotals {
    /** Totals for each account by reporting period. */
    reportedTotals!: ReportedTotals[];
    reportingPeriod?: ReportingPeriod;

    constructor(data?: IAccountTotals) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.reportedTotals = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportedTotals"])) {
                this.reportedTotals = [] as any;
                for (let item of _data["reportedTotals"])
                    this.reportedTotals!.push(ReportedTotals.fromJS(item));
            }
            this.reportingPeriod = _data["reportingPeriod"];
        }
    }

    static fromJS(data: any): AccountTotals {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTotals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportedTotals)) {
            data["reportedTotals"] = [];
            for (let item of this.reportedTotals)
                data["reportedTotals"].push(item.toJSON());
        }
        data["reportingPeriod"] = this.reportingPeriod;
        return data; 
    }

    clone(): AccountTotals {
        const json = this.toJSON();
        let result = new AccountTotals();
        result.init(json);
        return result;
    }
}

/** Account Totals model the starting, ending, and total change in account balance by reporting period. */
export interface IAccountTotals {
    /** Totals for each account by reporting period. */
    reportedTotals: ReportedTotals[];
    reportingPeriod?: ReportingPeriod;
}

/** Models a mailing address. */
export class Address implements IAddress {
    /** Specific parts of the address that have been identified. The set of Components does not necessarily provide a complete representation of the address. */
    components!: AddressComponent[];
    /** A complete representation of the address without any implied structure or formatting. */
    freeFormLines!: string[];
    /** A set of tags for the address intended to identify how the address is used. */
    tags!: AddressTag[];

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.components = [];
            this.freeFormLines = [];
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["components"])) {
                this.components = [] as any;
                for (let item of _data["components"])
                    this.components!.push(AddressComponent.fromJS(item));
            }
            if (Array.isArray(_data["freeFormLines"])) {
                this.freeFormLines = [] as any;
                for (let item of _data["freeFormLines"])
                    this.freeFormLines!.push(item);
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item.toJSON());
        }
        if (Array.isArray(this.freeFormLines)) {
            data["freeFormLines"] = [];
            for (let item of this.freeFormLines)
                data["freeFormLines"].push(item);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data; 
    }

    clone(): Address {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

/** Models a mailing address. */
export interface IAddress {
    /** Specific parts of the address that have been identified. The set of Components does not necessarily provide a complete representation of the address. */
    components: AddressComponent[];
    /** A complete representation of the address without any implied structure or formatting. */
    freeFormLines: string[];
    /** A set of tags for the address intended to identify how the address is used. */
    tags: AddressTag[];
}

/** Models a part of an address that has been identified. */
export class AddressComponent implements IAddressComponent {
    type!: ComponentOfAddress;
    /** A value for the part of the address that has been identified with no implied formatting. */
    value!: string;

    constructor(data?: IAddressComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AddressComponent {
        data = typeof data === 'object' ? data : {};
        let result = new AddressComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data; 
    }

    clone(): AddressComponent {
        const json = this.toJSON();
        let result = new AddressComponent();
        result.init(json);
        return result;
    }
}

/** Models a part of an address that has been identified. */
export interface IAddressComponent {
    type: ComponentOfAddress;
    /** A value for the part of the address that has been identified with no implied formatting. */
    value: string;
}

/** Defines a set of tags providing additional information about an address. |Enum Value|Description| |--|--| |POBox|The address represents a postal box rather than a physical address.| |Shipping|The address is used for delivery or receipt of products.| |Contact|The address is used as a public contact address.| |Invoicing|The address is used for invoicing.| |Legal|The address is used for legal purposes.| |Billing|The address is used for billing purposes.| */
export type AddressTag = "POBox" | "Shipping" | "Contact" | "Invoicing" | "Legal" | "Billing";

/** Models data for an aging bucket as found in an Aging Report. */
export class AgingBucket implements IAgingBucket {
    amountOutstanding!: DoubleEntryAmount;
    debtType?: DebtType;
    /** A label for the aging bucket. For example "> 120 days". */
    label!: string;
    /** The maximum age of receivables or payables included in this aging bucket (inclusive). May be null for aging bucket's like "> 120". */
    maximumAge?: number | undefined;
    /** The minimum age of receivables or payables included in this aging bucket (inclusive). May be null for aging bucket's like "< 31". */
    minimumAge?: number | undefined;

    constructor(data?: IAgingBucket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.amountOutstanding = new DoubleEntryAmount();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amountOutstanding = _data["amountOutstanding"] ? DoubleEntryAmount.fromJS(_data["amountOutstanding"]) : new DoubleEntryAmount();
            this.debtType = _data["debtType"];
            this.label = _data["label"];
            this.maximumAge = _data["maximumAge"];
            this.minimumAge = _data["minimumAge"];
        }
    }

    static fromJS(data: any): AgingBucket {
        data = typeof data === 'object' ? data : {};
        let result = new AgingBucket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountOutstanding"] = this.amountOutstanding ? this.amountOutstanding.toJSON() : <any>undefined;
        data["debtType"] = this.debtType;
        data["label"] = this.label;
        data["maximumAge"] = this.maximumAge;
        data["minimumAge"] = this.minimumAge;
        return data; 
    }

    clone(): AgingBucket {
        const json = this.toJSON();
        let result = new AgingBucket();
        result.init(json);
        return result;
    }
}

/** Models data for an aging bucket as found in an Aging Report. */
export interface IAgingBucket {
    amountOutstanding: DoubleEntryAmount;
    debtType?: DebtType;
    /** A label for the aging bucket. For example "> 120 days". */
    label: string;
    /** The maximum age of receivables or payables included in this aging bucket (inclusive). May be null for aging bucket's like "> 120". */
    maximumAge?: number | undefined;
    /** The minimum age of receivables or payables included in this aging bucket (inclusive). May be null for aging bucket's like "< 31". */
    minimumAge?: number | undefined;
}

/** Specifies whether receivables or payables are aged relative to their transaction date or relative to their due date. |Enum Value|Description| |--|--| |FromTransactionDate|The age of the receivable or payable is measured from the date the transaction occured. In other words, the age one day after the transaction date is 1.| |FromDueDate|The age of the receivable or payable is measured from the due date for that transaction. In other words, the age one day after the due date is 1. If no due date is specified, the date of the transaction is treated as the due date.| */
export type AgingMethod = "FromTransactionDate" | "FromDueDate";

/** Models receivables or payables aging as of a specific date. */
export class AgingReport implements IAgingReport {
    /** Data for each aging bucket. */
    agingBuckets!: AgingBucket[];
    agingMethod!: AgingMethod;
    /** The date corresponding to the receivables or payables aging data. */
    asOf!: string;
    module!: InvoicingModule;
    totalAmountOutstanding!: DoubleEntryAmount;

    constructor(data?: IAgingReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.agingBuckets = [];
            this.totalAmountOutstanding = new DoubleEntryAmount();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["agingBuckets"])) {
                this.agingBuckets = [] as any;
                for (let item of _data["agingBuckets"])
                    this.agingBuckets!.push(AgingBucket.fromJS(item));
            }
            this.agingMethod = _data["agingMethod"];
            this.asOf = _data["asOf"];
            this.module = _data["module"];
            this.totalAmountOutstanding = _data["totalAmountOutstanding"] ? DoubleEntryAmount.fromJS(_data["totalAmountOutstanding"]) : new DoubleEntryAmount();
        }
    }

    static fromJS(data: any): AgingReport {
        data = typeof data === 'object' ? data : {};
        let result = new AgingReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.agingBuckets)) {
            data["agingBuckets"] = [];
            for (let item of this.agingBuckets)
                data["agingBuckets"].push(item.toJSON());
        }
        data["agingMethod"] = this.agingMethod;
        data["asOf"] = this.asOf;
        data["module"] = this.module;
        data["totalAmountOutstanding"] = this.totalAmountOutstanding ? this.totalAmountOutstanding.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AgingReport {
        const json = this.toJSON();
        let result = new AgingReport();
        result.init(json);
        return result;
    }
}

/** Models receivables or payables aging as of a specific date. */
export interface IAgingReport {
    /** Data for each aging bucket. */
    agingBuckets: AgingBucket[];
    agingMethod: AgingMethod;
    /** The date corresponding to the receivables or payables aging data. */
    asOf: string;
    module: InvoicingModule;
    totalAmountOutstanding: DoubleEntryAmount;
}

/** This response may be used to describe a client error when returning a 400 HTTP status code. */
export class BadRequest implements IBadRequest {
    /** A description of the client error. */
    description!: string;
    /** The name of the parameter that was invalid, if applicable.
May be null or omitted. */
    parameter?: string | undefined;

    constructor(data?: IBadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.parameter = _data["parameter"];
        }
    }

    static fromJS(data: any): BadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["parameter"] = this.parameter;
        return data; 
    }

    clone(): BadRequest {
        const json = this.toJSON();
        let result = new BadRequest();
        result.init(json);
        return result;
    }
}

/** This response may be used to describe a client error when returning a 400 HTTP status code. */
export interface IBadRequest {
    /** A description of the client error. */
    description: string;
    /** The name of the parameter that was invalid, if applicable.
May be null or omitted. */
    parameter?: string | undefined;
}

/** Models an id and name for a person or organization with which the business transacts. For example, a customer, vendor, employee, or shareholder. */
export class BusinessRelationship implements IBusinessRelationship {
    /** An identifier for the business relationship, if specified. */
    id?: string | undefined;
    /** The name associated with the business relationship, if specified. */
    name?: string | undefined;

    constructor(data?: IBusinessRelationship) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BusinessRelationship {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRelationship();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): BusinessRelationship {
        const json = this.toJSON();
        let result = new BusinessRelationship();
        result.init(json);
        return result;
    }
}

/** Models an id and name for a person or organization with which the business transacts. For example, a customer, vendor, employee, or shareholder. */
export interface IBusinessRelationship {
    /** An identifier for the business relationship, if specified. */
    id?: string | undefined;
    /** The name associated with the business relationship, if specified. */
    name?: string | undefined;
}

/** Models a Chart Of Accounts, which provides a hierarchical listing of all accounts used for financial reporting. */
export class ChartOfAccounts implements IChartOfAccounts {
    /** A hierarchical representation of the accounts used for financial reporting. */
    hierarchy!: Account[];

    constructor(data?: IChartOfAccounts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hierarchy = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["hierarchy"])) {
                this.hierarchy = [] as any;
                for (let item of _data["hierarchy"])
                    this.hierarchy!.push(Account.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartOfAccounts {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccounts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hierarchy)) {
            data["hierarchy"] = [];
            for (let item of this.hierarchy)
                data["hierarchy"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ChartOfAccounts {
        const json = this.toJSON();
        let result = new ChartOfAccounts();
        result.init(json);
        return result;
    }
}

/** Models a Chart Of Accounts, which provides a hierarchical listing of all accounts used for financial reporting. */
export interface IChartOfAccounts {
    /** A hierarchical representation of the accounts used for financial reporting. */
    hierarchy: Account[];
}

/** Defines how an account appearing in the Chart Of Accounts is used. |Enum Value|Description| |--|--| |Bookkeeping|The account is used to record business transactions. Many accounting systems refer to these as 'Detail Accounts'.| |ReportHeader|The account is used for presentation purposes only. Many accounting systems refer to these accounts as 'Header Accounts'.| */
export type ChartOfAccountsRole = "Bookkeeping" | "ReportHeader";

/** Models a column header for a comparative financial statement. The column header contains information about the reporting period associated with each column. */
export class ColumnHeader implements IColumnHeader {
    /** A label for the column header. For example "FY 2019". */
    label?: string | undefined;
    /** The end date of the reporting period for which the financial data was prepared (inclusive). */
    reportingEndDate!: string;
    /** The start date of the reporting period for which the financial data was prepared (inclusive). May be null for point-in-time statements such as the Balance Sheet. */
    reportingStartDate?: string | undefined;

    constructor(data?: IColumnHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.reportingEndDate = _data["reportingEndDate"];
            this.reportingStartDate = _data["reportingStartDate"];
        }
    }

    static fromJS(data: any): ColumnHeader {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["reportingEndDate"] = this.reportingEndDate;
        data["reportingStartDate"] = this.reportingStartDate;
        return data; 
    }

    clone(): ColumnHeader {
        const json = this.toJSON();
        let result = new ColumnHeader();
        result.init(json);
        return result;
    }
}

/** Models a column header for a comparative financial statement. The column header contains information about the reporting period associated with each column. */
export interface IColumnHeader {
    /** A label for the column header. For example "FY 2019". */
    label?: string | undefined;
    /** The end date of the reporting period for which the financial data was prepared (inclusive). */
    reportingEndDate: string;
    /** The start date of the reporting period for which the financial data was prepared (inclusive). May be null for point-in-time statements such as the Balance Sheet. */
    reportingStartDate?: string | undefined;
}

/** Models a Comparative Balance Sheet (aka The Statement of Financial Position). */
export class ComparativeBalanceSheet implements IComparativeBalanceSheet {
    accountingMethod!: AccountingMethod;
    /** The column headers contain information about the reporting periods represented in the comparative financial statement. */
    columnHeaders!: ColumnHeader[];
    currency?: Currency;
    /** An optional set of notes for the financial statement. May be empty. */
    footnotes!: string[];
    /** The set of line items appearing in the financial statement. */
    lineItems!: LineItem[];
    /** The name of the organization associated with the financial statement. May be null. */
    organizationName?: string | undefined;
    /** A whole number indicating if, for example, monetary amounts are represented in actual (1), thousands (1,000), or millions (1,000,000). */
    scalingFactor!: number;
    /** The time at which the financial statement was prepared. */
    dataAsOfTime!: string;
    /** A title for the financial statement that was prepared. Example: "Balance Sheet". */
    title!: string;

    constructor(data?: IComparativeBalanceSheet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.columnHeaders = [];
            this.footnotes = [];
            this.lineItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountingMethod = _data["accountingMethod"];
            if (Array.isArray(_data["columnHeaders"])) {
                this.columnHeaders = [] as any;
                for (let item of _data["columnHeaders"])
                    this.columnHeaders!.push(ColumnHeader.fromJS(item));
            }
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            if (Array.isArray(_data["footnotes"])) {
                this.footnotes = [] as any;
                for (let item of _data["footnotes"])
                    this.footnotes!.push(item);
            }
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems!.push(LineItem.fromJS(item));
            }
            this.organizationName = _data["organizationName"];
            this.scalingFactor = _data["scalingFactor"];
            this.dataAsOfTime = _data["dataAsOfTime"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ComparativeBalanceSheet {
        data = typeof data === 'object' ? data : {};
        let result = new ComparativeBalanceSheet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingMethod"] = this.accountingMethod;
        if (Array.isArray(this.columnHeaders)) {
            data["columnHeaders"] = [];
            for (let item of this.columnHeaders)
                data["columnHeaders"].push(item.toJSON());
        }
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        if (Array.isArray(this.footnotes)) {
            data["footnotes"] = [];
            for (let item of this.footnotes)
                data["footnotes"].push(item);
        }
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        data["organizationName"] = this.organizationName;
        data["scalingFactor"] = this.scalingFactor;
        data["dataAsOfTime"] = this.dataAsOfTime;
        data["title"] = this.title;
        return data; 
    }

    clone(): ComparativeBalanceSheet {
        const json = this.toJSON();
        let result = new ComparativeBalanceSheet();
        result.init(json);
        return result;
    }
}

/** Models a Comparative Balance Sheet (aka The Statement of Financial Position). */
export interface IComparativeBalanceSheet {
    accountingMethod: AccountingMethod;
    /** The column headers contain information about the reporting periods represented in the comparative financial statement. */
    columnHeaders: ColumnHeader[];
    currency?: Currency;
    /** An optional set of notes for the financial statement. May be empty. */
    footnotes: string[];
    /** The set of line items appearing in the financial statement. */
    lineItems: LineItem[];
    /** The name of the organization associated with the financial statement. May be null. */
    organizationName?: string | undefined;
    /** A whole number indicating if, for example, monetary amounts are represented in actual (1), thousands (1,000), or millions (1,000,000). */
    scalingFactor: number;
    /** The time at which the financial statement was prepared. */
    dataAsOfTime: string;
    /** A title for the financial statement that was prepared. Example: "Balance Sheet". */
    title: string;
}

/** Models a Comparative Income Statement (aka The Profit and Loss Statement). */
export class ComparativeIncomeStatement implements IComparativeIncomeStatement {
    accountingMethod!: AccountingMethod;
    /** The column headers contain information about the reporting periods represented in the comparative financial statement. */
    columnHeaders!: ColumnHeader[];
    currency?: Currency;
    /** An optional set of notes for the financial statement. May be empty. */
    footnotes!: string[];
    /** The set of line items appearing in the financial statement. */
    lineItems!: LineItem[];
    /** The name of the organization associated with the financial statement. May be null. */
    organizationName?: string | undefined;
    /** A whole number indicating if, for example, monetary amounts are represented in actual (1), thousands (1,000), or millions (1,000,000). */
    scalingFactor!: number;
    /** The time at which the financial statement was prepared. */
    dataAsOfTime!: string;
    /** A title for the financial statement that was prepared. Example: "Balance Sheet". */
    title!: string;

    constructor(data?: IComparativeIncomeStatement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.columnHeaders = [];
            this.footnotes = [];
            this.lineItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountingMethod = _data["accountingMethod"];
            if (Array.isArray(_data["columnHeaders"])) {
                this.columnHeaders = [] as any;
                for (let item of _data["columnHeaders"])
                    this.columnHeaders!.push(ColumnHeader.fromJS(item));
            }
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            if (Array.isArray(_data["footnotes"])) {
                this.footnotes = [] as any;
                for (let item of _data["footnotes"])
                    this.footnotes!.push(item);
            }
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems!.push(LineItem.fromJS(item));
            }
            this.organizationName = _data["organizationName"];
            this.scalingFactor = _data["scalingFactor"];
            this.dataAsOfTime = _data["dataAsOfTime"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ComparativeIncomeStatement {
        data = typeof data === 'object' ? data : {};
        let result = new ComparativeIncomeStatement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingMethod"] = this.accountingMethod;
        if (Array.isArray(this.columnHeaders)) {
            data["columnHeaders"] = [];
            for (let item of this.columnHeaders)
                data["columnHeaders"].push(item.toJSON());
        }
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        if (Array.isArray(this.footnotes)) {
            data["footnotes"] = [];
            for (let item of this.footnotes)
                data["footnotes"].push(item);
        }
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        data["organizationName"] = this.organizationName;
        data["scalingFactor"] = this.scalingFactor;
        data["dataAsOfTime"] = this.dataAsOfTime;
        data["title"] = this.title;
        return data; 
    }

    clone(): ComparativeIncomeStatement {
        const json = this.toJSON();
        let result = new ComparativeIncomeStatement();
        result.init(json);
        return result;
    }
}

/** Models a Comparative Income Statement (aka The Profit and Loss Statement). */
export interface IComparativeIncomeStatement {
    accountingMethod: AccountingMethod;
    /** The column headers contain information about the reporting periods represented in the comparative financial statement. */
    columnHeaders: ColumnHeader[];
    currency?: Currency;
    /** An optional set of notes for the financial statement. May be empty. */
    footnotes: string[];
    /** The set of line items appearing in the financial statement. */
    lineItems: LineItem[];
    /** The name of the organization associated with the financial statement. May be null. */
    organizationName?: string | undefined;
    /** A whole number indicating if, for example, monetary amounts are represented in actual (1), thousands (1,000), or millions (1,000,000). */
    scalingFactor: number;
    /** The time at which the financial statement was prepared. */
    dataAsOfTime: string;
    /** A title for the financial statement that was prepared. Example: "Balance Sheet". */
    title: string;
}

/** Defines the set of address component types that can be identified. |Enum Value|Description| |--|--| |Addressee|A name for a person, organization, building, or venue appearing as part of the address.| |POBoxNumber|A Postal Box number.| |Unit|An apartment, unit, office, lot, or room number.| |Floor|A floor number| |StreetAndNumber|A street or route name and building number.| |Neighborhood|A suburb or other unofficial neighborhood name.| |District|A district, borough, or other second-level municipality.| |PostalCode|A postal / zip code.| |City|The name of a city, town, village, hamlet, locality, or other first-level municipality.| |County|A second-level administrative division for a country.| |StateOrProvince|A first-level administrative division for a country.| |Region|An informal geographic region smaller than a country including named islands.| |Country|Sovereign nations and their dependent territories. See ISO 3166-1.| |WorldRegion|An informal geographic region larger than a country.| */
export type ComponentOfAddress = "Addressee" | "POBoxNumber" | "Unit" | "Floor" | "StreetAndNumber" | "Neighborhood" | "District" | "PostalCode" | "City" | "County" | "StateOrProvince" | "Region" | "Country" | "WorldRegion";

/** Defines the types of phone number components. |Enum Value|Description| |--|--| |AreaCode|A numeric prefix used by various telephone numbering plans for routing between geographic areas and for provisioning.| |CountryCallingCode|A telephone number prefix that is used for international calls.| |Extension|An extension number for the phone number.| |NationalNumber|A representation of the phone number excluding the Country Calling Code and any extension, but including area code [for numbering plans having one]. Domestic calls can be made using the national number alone.| |LocalNumber|The local part of the phone number excluding the area code. 7-digits in the NANP.| */
export type ComponentOfPhoneNumber = "AreaCode" | "CountryCallingCode" | "Extension" | "NationalNumber" | "LocalNumber";

/** Models a Connection to an external Dataset. */
export class Connection implements IConnection {
    state!: ConnectionState;
    /** An identifier for the external Dataset associated with the Connection. */
    datasetId!: string;
    /** A friendly name for the external Dataset associated with the Connection. */
    datasetName?: string | undefined;
    /** The name identifier of a datasource. Ex: 'quickbooksonline'. */
    datasourceNameId!: string;
    /** An identifier for the Connection. */
    id!: string;
    /** An identifier for the Organization for which the Connection was created. */
    orgId!: string;

    constructor(data?: IConnection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.datasetId = _data["datasetId"];
            this.datasetName = _data["datasetName"];
            this.datasourceNameId = _data["datasourceNameId"];
            this.id = _data["id"];
            this.orgId = _data["orgId"];
        }
    }

    static fromJS(data: any): Connection {
        data = typeof data === 'object' ? data : {};
        let result = new Connection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["datasetId"] = this.datasetId;
        data["datasetName"] = this.datasetName;
        data["datasourceNameId"] = this.datasourceNameId;
        data["id"] = this.id;
        data["orgId"] = this.orgId;
        return data; 
    }

    clone(): Connection {
        const json = this.toJSON();
        let result = new Connection();
        result.init(json);
        return result;
    }
}

/** Models a Connection to an external Dataset. */
export interface IConnection {
    state: ConnectionState;
    /** An identifier for the external Dataset associated with the Connection. */
    datasetId: string;
    /** A friendly name for the external Dataset associated with the Connection. */
    datasetName?: string | undefined;
    /** The name identifier of a datasource. Ex: 'quickbooksonline'. */
    datasourceNameId: string;
    /** An identifier for the Connection. */
    id: string;
    /** An identifier for the Organization for which the Connection was created. */
    orgId: string;
}

/** A descriptor for a Connection to an external Dataset. */
export class ConnectionDescriptor implements IConnectionDescriptor {
    /** An identifier for the external Dataset associated with the Connection. */
    datasetId!: string;
    /** A friendly name for the external Dataset associated with the Connection. */
    datasetName?: string | undefined;
    /** The name identifier of a datasource. Ex: 'quickbooksonline'. */
    datasourceNameId!: string;
    /** An identifier for the Connection. */
    id!: string;
    /** An identifier for the Organization for which the Connection was created. */
    orgId!: string;

    constructor(data?: IConnectionDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datasetId = _data["datasetId"];
            this.datasetName = _data["datasetName"];
            this.datasourceNameId = _data["datasourceNameId"];
            this.id = _data["id"];
            this.orgId = _data["orgId"];
        }
    }

    static fromJS(data: any): ConnectionDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasetId"] = this.datasetId;
        data["datasetName"] = this.datasetName;
        data["datasourceNameId"] = this.datasourceNameId;
        data["id"] = this.id;
        data["orgId"] = this.orgId;
        return data; 
    }

    clone(): ConnectionDescriptor {
        const json = this.toJSON();
        let result = new ConnectionDescriptor();
        result.init(json);
        return result;
    }
}

/** A descriptor for a Connection to an external Dataset. */
export interface IConnectionDescriptor {
    /** An identifier for the external Dataset associated with the Connection. */
    datasetId: string;
    /** A friendly name for the external Dataset associated with the Connection. */
    datasetName?: string | undefined;
    /** The name identifier of a datasource. Ex: 'quickbooksonline'. */
    datasourceNameId: string;
    /** An identifier for the Connection. */
    id: string;
    /** An identifier for the Organization for which the Connection was created. */
    orgId: string;
}

/** Models a Connection Request. */
export class ConnectionRequest implements IConnectionRequest {
    /** If the Status of the Connection Request is Success, this will be an identifier for the Connection to the datasource. */
    connectionId?: string | undefined;
    /** An identifier for the Connection Request. */
    id!: string;
    errorCode?: ConnectionRequestErrorCode;
    /** If the Status of the Connection Request is Error, and ErrorDescription provides a user friendly description of to better understand why the Connection Request was not successful. */
    errorDescription?: string | undefined;
    /** An identifier for the Organization for which the datasource is being connected. */
    orgId!: string;
    status!: ConnectionRequestStatus;
    /** A name identifier for the datasource being connected to. */
    datasourceNameId!: string;

    constructor(data?: IConnectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionId = _data["connectionId"];
            this.id = _data["id"];
            this.errorCode = _data["errorCode"];
            this.errorDescription = _data["errorDescription"];
            this.orgId = _data["orgId"];
            this.status = _data["status"];
            this.datasourceNameId = _data["datasourceNameId"];
        }
    }

    static fromJS(data: any): ConnectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionId"] = this.connectionId;
        data["id"] = this.id;
        data["errorCode"] = this.errorCode;
        data["errorDescription"] = this.errorDescription;
        data["orgId"] = this.orgId;
        data["status"] = this.status;
        data["datasourceNameId"] = this.datasourceNameId;
        return data; 
    }

    clone(): ConnectionRequest {
        const json = this.toJSON();
        let result = new ConnectionRequest();
        result.init(json);
        return result;
    }
}

/** Models a Connection Request. */
export interface IConnectionRequest {
    /** If the Status of the Connection Request is Success, this will be an identifier for the Connection to the datasource. */
    connectionId?: string | undefined;
    /** An identifier for the Connection Request. */
    id: string;
    errorCode?: ConnectionRequestErrorCode;
    /** If the Status of the Connection Request is Error, and ErrorDescription provides a user friendly description of to better understand why the Connection Request was not successful. */
    errorDescription?: string | undefined;
    /** An identifier for the Organization for which the datasource is being connected. */
    orgId: string;
    status: ConnectionRequestStatus;
    /** A name identifier for the datasource being connected to. */
    datasourceNameId: string;
}

/** A descriptor for a newly created Connnection Request. */
export class ConnectionRequestDescriptor implements IConnectionRequestDescriptor {
    /** The URL to which the user should be directed for them to connect the datasource. */
    connectionEndpoint?: string | undefined;
    /** The `connectionEndpoint` URL in this response cannot be used beyond this expiration time. */
    expiration!: string;
    /** An identifier for the Connection Request. */
    id!: string;
    /** An identifier for the Organization for which the datasource is being connected. */
    orgId!: string;
    /** A name identifier for the datasource being connected to. */
    datasourceNameId!: string;

    constructor(data?: IConnectionRequestDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionEndpoint = _data["connectionEndpoint"];
            this.expiration = _data["expiration"];
            this.id = _data["id"];
            this.orgId = _data["orgId"];
            this.datasourceNameId = _data["datasourceNameId"];
        }
    }

    static fromJS(data: any): ConnectionRequestDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionRequestDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionEndpoint"] = this.connectionEndpoint;
        data["expiration"] = this.expiration;
        data["id"] = this.id;
        data["orgId"] = this.orgId;
        data["datasourceNameId"] = this.datasourceNameId;
        return data; 
    }

    clone(): ConnectionRequestDescriptor {
        const json = this.toJSON();
        let result = new ConnectionRequestDescriptor();
        result.init(json);
        return result;
    }
}

/** A descriptor for a newly created Connnection Request. */
export interface IConnectionRequestDescriptor {
    /** The URL to which the user should be directed for them to connect the datasource. */
    connectionEndpoint?: string | undefined;
    /** The `connectionEndpoint` URL in this response cannot be used beyond this expiration time. */
    expiration: string;
    /** An identifier for the Connection Request. */
    id: string;
    /** An identifier for the Organization for which the datasource is being connected. */
    orgId: string;
    /** A name identifier for the datasource being connected to. */
    datasourceNameId: string;
}

/** Specifies the high-level reason why a Connection Request was not successful. |Enum Value|Description| |--|--| |None|No error.| |UserCancelled|The user chose not to grant access to the datasource.| |RequestNonceAlreadyUsed|The Connection Request failed because it was attempted more than once.| |RequestExpired|The Connection Request failed because it was not completed within the required time frame.| |DatasourceUnresponsive|The Connection Request failed because the datasource was not responsive or returned an error. For example, 503 or 500 response received and re-attempting to did help.| |InsufficientUserPermissions|The user did not have sufficient privileges to grant access to the datasource.| |InternalError|An internal error occured. Reach out to our support team to get help.| */
export type ConnectionRequestErrorCode = "None" | "UserCancelled" | "RequestNonceAlreadyUsed" | "RequestExpired" | "DatasourceUnresponsive" | "InsufficientUserPermissions" | "InternalError";

/** Represents the parameters that are required to create a Connection Request. */
export class ConnectionRequestParameters implements IConnectionRequestParameters {
    /** A name identifier for the datasource being connected to. */
    datasourceNameId!: string;

    constructor(data?: IConnectionRequestParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datasourceNameId = _data["datasourceNameId"];
        }
    }

    static fromJS(data: any): ConnectionRequestParameters {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionRequestParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasourceNameId"] = this.datasourceNameId;
        return data; 
    }

    clone(): ConnectionRequestParameters {
        const json = this.toJSON();
        let result = new ConnectionRequestParameters();
        result.init(json);
        return result;
    }
}

/** Represents the parameters that are required to create a Connection Request. */
export interface IConnectionRequestParameters {
    /** A name identifier for the datasource being connected to. */
    datasourceNameId: string;
}

/** Specifies the status of a Connection Request. |Enum Value|Description| |--|--| |NotStarted|The Connection Request has been created, but has not yet started.| |Started|The Connection Request is in progress.| |Success|The Connection Request was successful.| |Error|The Connection Request was not successful.| */
export type ConnectionRequestStatus = "NotStarted" | "Started" | "Success" | "Error";

/** Models a list of Connections. */
export class ConnectionsList implements IConnectionsList {
    /** The set of Connections listed. */
    connections!: ConnectionDescriptor[];

    constructor(data?: IConnectionsList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.connections = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["connections"])) {
                this.connections = [] as any;
                for (let item of _data["connections"])
                    this.connections!.push(ConnectionDescriptor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConnectionsList {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionsList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.connections)) {
            data["connections"] = [];
            for (let item of this.connections)
                data["connections"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ConnectionsList {
        const json = this.toJSON();
        let result = new ConnectionsList();
        result.init(json);
        return result;
    }
}

/** Models a list of Connections. */
export interface IConnectionsList {
    /** The set of Connections listed. */
    connections: ConnectionDescriptor[];
}

/** Specifies the current status of a Connection. |Enum Value|Description| |--|--| |Disconnected|The Connection can no longer be used.| |Connected|The Connection can be used.| */
export type ConnectionState = "Disconnected" | "Connected";

/** Models additional metadata that can be attached to an API resource by the API consumer. */
export class ConsumerMetadata implements IConsumerMetadata {
    /** A label or key for the metadata that can be used to identify it. */
    label!: string;
    /** A value for the metadata. Null is allowed. */
    value?: string | undefined;

    constructor(data?: IConsumerMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ConsumerMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): ConsumerMetadata {
        const json = this.toJSON();
        let result = new ConsumerMetadata();
        result.init(json);
        return result;
    }
}

/** Models additional metadata that can be attached to an API resource by the API consumer. */
export interface IConsumerMetadata {
    /** A label or key for the metadata that can be used to identify it. */
    label: string;
    /** A value for the metadata. Null is allowed. */
    value?: string | undefined;
}

/** Models information about a country. */
export class Country implements ICountry {
    /** The ISO 3166 2-digit Country Code if known. */
    code?: string | undefined;
    /** A label for the country without any implied formatting or validation. */
    label!: string;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["label"] = this.label;
        return data; 
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

/** Models information about a country. */
export interface ICountry {
    /** The ISO 3166 2-digit Country Code if known. */
    code?: string | undefined;
    /** A label for the country without any implied formatting or validation. */
    label: string;
}

/** Indicates whether an amount represents a credit, debit, or neither (zero). |Enum Value|Description| |--|--| |Zero|The amount is zero. Neither a credit or a debit.| |Credit|The amount represents a credit. Equity and liabilities typically have a credit balance. Revenue is typically credited.| |Debit|The amount represents a debit. Assets typically have a debit balance and expenses are typically debited.| */
export type CreditOrDebit = "Zero" | "Credit" | "Debit";

/** Models information about a particular currency. */
export class Currency implements ICurrency {
    /** The ISO 4217 alphabetic code if known. */
    code?: string | undefined;
    /** A label for the currency without any implied formatting or validation. */
    label!: string;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["label"] = this.label;
        return data; 
    }

    clone(): Currency {
        const json = this.toJSON();
        let result = new Currency();
        result.init(json);
        return result;
    }
}

/** Models information about a particular currency. */
export interface ICurrency {
    /** The ISO 4217 alphabetic code if known. */
    code?: string | undefined;
    /** A label for the currency without any implied formatting or validation. */
    label: string;
}

/** Models information about where financial data was sourced from. */
export class Dataset implements IDataset {
    /** An identifier for the dataset from which the financial data originated. Unique within the scope of the datasource. */
    datasetId!: string;
    /** An identifier for the Accounting System or other datasource from which the financial data originated. */
    datasourceNameId!: string;

    constructor(data?: IDataset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datasetId = _data["datasetId"];
            this.datasourceNameId = _data["datasourceNameId"];
        }
    }

    static fromJS(data: any): Dataset {
        data = typeof data === 'object' ? data : {};
        let result = new Dataset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasetId"] = this.datasetId;
        data["datasourceNameId"] = this.datasourceNameId;
        return data; 
    }

    clone(): Dataset {
        const json = this.toJSON();
        let result = new Dataset();
        result.init(json);
        return result;
    }
}

/** Models information about where financial data was sourced from. */
export interface IDataset {
    /** An identifier for the dataset from which the financial data originated. Unique within the scope of the datasource. */
    datasetId: string;
    /** An identifier for the Accounting System or other datasource from which the financial data originated. */
    datasourceNameId: string;
}

/** Used to specify whether an outstanding debt represents money owed or due. |Enum Value|Description| |--|--| |OwedTo|Money is owed to an external entity.| |DueFrom|Money is due from an external entity.| */
export type DebtType = "OwedTo" | "DueFrom";

/** Models an amount credited or debited. */
export class DoubleEntryAmount implements IDoubleEntryAmount {
    /** The scalar amount. Always positive or 0. */
    amount!: number;
    type!: CreditOrDebit;

    constructor(data?: IDoubleEntryAmount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): DoubleEntryAmount {
        data = typeof data === 'object' ? data : {};
        let result = new DoubleEntryAmount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["type"] = this.type;
        return data; 
    }

    clone(): DoubleEntryAmount {
        const json = this.toJSON();
        let result = new DoubleEntryAmount();
        result.init(json);
        return result;
    }
}

/** Models an amount credited or debited. */
export interface IDoubleEntryAmount {
    /** The scalar amount. Always positive or 0. */
    amount: number;
    type: CreditOrDebit;
}

/** Models an email address. */
export class EmailAddress implements IEmailAddress {
    /** A name or description of the contact associated with the email. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** The value for the email address without any implied formatting or validation. */
    value!: string;

    constructor(data?: IEmailAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contact = _data["contact"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact;
        data["value"] = this.value;
        return data; 
    }

    clone(): EmailAddress {
        const json = this.toJSON();
        let result = new EmailAddress();
        result.init(json);
        return result;
    }
}

/** Models an email address. */
export interface IEmailAddress {
    /** A name or description of the contact associated with the email. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** The value for the email address without any implied formatting or validation. */
    value: string;
}

/** Specifies the high-level reason why a Financial Import was not successful. |Enum Value|Description| |--|--| |None|No error.| |InsufficientUserPermissions|The end-user did not have or did not grant sufficient privileges to access the requested financials.| |DatasourceUnresponsive|The 3rd party service providing the financial data is not responding or has responded with one or more error messages. 5xx HTTP responses from the datasource are a typical example. Re-attempting the financial import after some time may be merited, but you can reach out to our support team so that we can help to get the issue resolved as soon as is possible.| |InternalError|An internal error occured. Reach out to our support team to get help.| |Disconnected|The Connection to the datasource requires authorization. This can happen if the authorization has expired or was revoked by the end-user. The end-user must reconnect their Accounting System or other financial datasource to import financials successfully.| |Cancelled|The financial import was cancelled by the end-user, the datasource, the API consumer, or by the Strongbox Platform.| */
export type FinancialImportErrorCode = "None" | "InsufficientUserPermissions" | "DatasourceUnresponsive" | "InternalError" | "Disconnected" | "Cancelled";

/** Specifies the outcome of importing new financial data. |Enum Value|Description| |--|--| |Pending|The outcome is still pending.| |Success|Importing the financial data is complete.| |Error|Importing the financial data failed.| */
export type FinancialImportOutcome = "Pending" | "Success" | "Error";

/** Models parameters that are required to import new financial data. */
export class FinancialImportParameters implements IFinancialImportParameters {
    /** An identifier for the Connection used to import financials. */
    accountingConnectionId!: string;
    /** Optional metadata to associate with the Financial Record. For example, you might associate the Financial Record with an identifier for a specific Loan Submission in your own system. */
    consumerMetadata?: ConsumerMetadata[] | undefined;
    /** This parameter is used as the end date for period-to-date financial data. Please use ISO 8601 date format "YYYY-MM-DD". */
    reportingEndDate!: string;
    accountingDataImportOptions?: AccountingImportOptions;

    constructor(data?: IFinancialImportParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountingConnectionId = _data["accountingConnectionId"];
            if (Array.isArray(_data["consumerMetadata"])) {
                this.consumerMetadata = [] as any;
                for (let item of _data["consumerMetadata"])
                    this.consumerMetadata!.push(ConsumerMetadata.fromJS(item));
            }
            this.reportingEndDate = _data["reportingEndDate"];
            this.accountingDataImportOptions = _data["accountingDataImportOptions"] ? AccountingImportOptions.fromJS(_data["accountingDataImportOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FinancialImportParameters {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialImportParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountingConnectionId"] = this.accountingConnectionId;
        if (Array.isArray(this.consumerMetadata)) {
            data["consumerMetadata"] = [];
            for (let item of this.consumerMetadata)
                data["consumerMetadata"].push(item.toJSON());
        }
        data["reportingEndDate"] = this.reportingEndDate;
        data["accountingDataImportOptions"] = this.accountingDataImportOptions ? this.accountingDataImportOptions.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FinancialImportParameters {
        const json = this.toJSON();
        let result = new FinancialImportParameters();
        result.init(json);
        return result;
    }
}

/** Models parameters that are required to import new financial data. */
export interface IFinancialImportParameters {
    /** An identifier for the Connection used to import financials. */
    accountingConnectionId: string;
    /** Optional metadata to associate with the Financial Record. For example, you might associate the Financial Record with an identifier for a specific Loan Submission in your own system. */
    consumerMetadata?: ConsumerMetadata[] | undefined;
    /** This parameter is used as the end date for period-to-date financial data. Please use ISO 8601 date format "YYYY-MM-DD". */
    reportingEndDate: string;
    accountingDataImportOptions?: AccountingImportOptions;
}

/** Models the status of importing new financial data to create a Financial Record. */
export class FinancialImportStatus implements IFinancialImportStatus {
    errorCode?: FinancialImportErrorCode;
    /** If the Outcome is Error, then the ErrorDescription provides a description of the problem that occurred when attempting to import financials. */
    errorDescription?: string | undefined;
    outcome!: FinancialImportOutcome;

    constructor(data?: IFinancialImportStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"];
            this.errorDescription = _data["errorDescription"];
            this.outcome = _data["outcome"];
        }
    }

    static fromJS(data: any): FinancialImportStatus {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialImportStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode;
        data["errorDescription"] = this.errorDescription;
        data["outcome"] = this.outcome;
        return data; 
    }

    clone(): FinancialImportStatus {
        const json = this.toJSON();
        let result = new FinancialImportStatus();
        result.init(json);
        return result;
    }
}

/** Models the status of importing new financial data to create a Financial Record. */
export interface IFinancialImportStatus {
    errorCode?: FinancialImportErrorCode;
    /** If the Outcome is Error, then the ErrorDescription provides a description of the problem that occurred when attempting to import financials. */
    errorDescription?: string | undefined;
    outcome: FinancialImportOutcome;
}

/** Models imported financials. */
export class FinancialRecord implements IFinancialRecord {
    /** Additional metadata associated with the Financial Record that was added, by you, the API consumer. For example, you might associate the Financial Record with an identifier for a specific Loan Submission in your own system. */
    consumerMetadata!: ConsumerMetadata[];
    /** The time at which the financial data was imported. */
    dataAsOfTime!: string;
    accountingDataset!: Dataset;
    /** An identifier for the Financial Record. */
    id!: string;
    importStatus!: FinancialImportStatus;
    /** The end date for period-to-date financial data. Serialized using ISO 8601 date format "YYYY-MM-DD". */
    reportingEndDate!: string;
    /** Specifies whether the financial data was imported on-demand or via a schedule. */
    scheduled!: boolean;
    accountingDataImportOptions!: AccountingImportOptions;

    constructor(data?: IFinancialRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.consumerMetadata = [];
            this.accountingDataset = new Dataset();
            this.importStatus = new FinancialImportStatus();
            this.accountingDataImportOptions = new AccountingImportOptions();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["consumerMetadata"])) {
                this.consumerMetadata = [] as any;
                for (let item of _data["consumerMetadata"])
                    this.consumerMetadata!.push(ConsumerMetadata.fromJS(item));
            }
            this.dataAsOfTime = _data["dataAsOfTime"];
            this.accountingDataset = _data["accountingDataset"] ? Dataset.fromJS(_data["accountingDataset"]) : new Dataset();
            this.id = _data["id"];
            this.importStatus = _data["importStatus"] ? FinancialImportStatus.fromJS(_data["importStatus"]) : new FinancialImportStatus();
            this.reportingEndDate = _data["reportingEndDate"];
            this.scheduled = _data["scheduled"];
            this.accountingDataImportOptions = _data["accountingDataImportOptions"] ? AccountingImportOptions.fromJS(_data["accountingDataImportOptions"]) : new AccountingImportOptions();
        }
    }

    static fromJS(data: any): FinancialRecord {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.consumerMetadata)) {
            data["consumerMetadata"] = [];
            for (let item of this.consumerMetadata)
                data["consumerMetadata"].push(item.toJSON());
        }
        data["dataAsOfTime"] = this.dataAsOfTime;
        data["accountingDataset"] = this.accountingDataset ? this.accountingDataset.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["importStatus"] = this.importStatus ? this.importStatus.toJSON() : <any>undefined;
        data["reportingEndDate"] = this.reportingEndDate;
        data["scheduled"] = this.scheduled;
        data["accountingDataImportOptions"] = this.accountingDataImportOptions ? this.accountingDataImportOptions.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FinancialRecord {
        const json = this.toJSON();
        let result = new FinancialRecord();
        result.init(json);
        return result;
    }
}

/** Models imported financials. */
export interface IFinancialRecord {
    /** Additional metadata associated with the Financial Record that was added, by you, the API consumer. For example, you might associate the Financial Record with an identifier for a specific Loan Submission in your own system. */
    consumerMetadata: ConsumerMetadata[];
    /** The time at which the financial data was imported. */
    dataAsOfTime: string;
    accountingDataset: Dataset;
    /** An identifier for the Financial Record. */
    id: string;
    importStatus: FinancialImportStatus;
    /** The end date for period-to-date financial data. Serialized using ISO 8601 date format "YYYY-MM-DD". */
    reportingEndDate: string;
    /** Specifies whether the financial data was imported on-demand or via a schedule. */
    scheduled: boolean;
    accountingDataImportOptions: AccountingImportOptions;
}

/** Models a list of Financial Records. */
export class FinancialRecordList implements IFinancialRecordList {
    /** The set of Financial Records listed. */
    financialRecords!: FinancialRecord[];

    constructor(data?: IFinancialRecordList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.financialRecords = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["financialRecords"])) {
                this.financialRecords = [] as any;
                for (let item of _data["financialRecords"])
                    this.financialRecords!.push(FinancialRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinancialRecordList {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRecordList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.financialRecords)) {
            data["financialRecords"] = [];
            for (let item of this.financialRecords)
                data["financialRecords"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FinancialRecordList {
        const json = this.toJSON();
        let result = new FinancialRecordList();
        result.init(json);
        return result;
    }
}

/** Models a list of Financial Records. */
export interface IFinancialRecordList {
    /** The set of Financial Records listed. */
    financialRecords: FinancialRecord[];
}

/** A reference to a Financial Record by its id. */
export class FinancialRecordReference implements IFinancialRecordReference {
    /** An identifier for a Financial Record. */
    financialRecordId!: string;

    constructor(data?: IFinancialRecordReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.financialRecordId = _data["financialRecordId"];
        }
    }

    static fromJS(data: any): FinancialRecordReference {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRecordReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["financialRecordId"] = this.financialRecordId;
        return data; 
    }

    clone(): FinancialRecordReference {
        const json = this.toJSON();
        let result = new FinancialRecordReference();
        result.init(json);
        return result;
    }
}

/** A reference to a Financial Record by its id. */
export interface IFinancialRecordReference {
    /** An identifier for a Financial Record. */
    financialRecordId: string;
}

/** Used to configure the financial statements that are collected from the accounting system. */
export class FinancialStatementImportOptions implements IFinancialStatementImportOptions {
    reportingPeriod?: ReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods!: number;

    constructor(data?: IFinancialStatementImportOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportingPeriod = _data["reportingPeriod"];
            this.numberOfPeriods = _data["numberOfPeriods"];
        }
    }

    static fromJS(data: any): FinancialStatementImportOptions {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialStatementImportOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportingPeriod"] = this.reportingPeriod;
        data["numberOfPeriods"] = this.numberOfPeriods;
        return data; 
    }

    clone(): FinancialStatementImportOptions {
        const json = this.toJSON();
        let result = new FinancialStatementImportOptions();
        result.init(json);
        return result;
    }
}

/** Used to configure the financial statements that are collected from the accounting system. */
export interface IFinancialStatementImportOptions {
    reportingPeriod?: ReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods: number;
}

/** Models information about a Financial Workbook that can be downloaded. */
export class FinancialWorkbook implements IFinancialWorkbook {
    /** An identifier for the Financial Workbook variant. */
    variantId!: string;
    /** The filename associated with the Financial Workbook. */
    filename!: string;
    /** The time at which the Financial Workbook was created. */
    creationTime!: string;

    constructor(data?: IFinancialWorkbook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.variantId = _data["variantId"];
            this.filename = _data["filename"];
            this.creationTime = _data["creationTime"];
        }
    }

    static fromJS(data: any): FinancialWorkbook {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialWorkbook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variantId"] = this.variantId;
        data["filename"] = this.filename;
        data["creationTime"] = this.creationTime;
        return data; 
    }

    clone(): FinancialWorkbook {
        const json = this.toJSON();
        let result = new FinancialWorkbook();
        result.init(json);
        return result;
    }
}

/** Models information about a Financial Workbook that can be downloaded. */
export interface IFinancialWorkbook {
    /** An identifier for the Financial Workbook variant. */
    variantId: string;
    /** The filename associated with the Financial Workbook. */
    filename: string;
    /** The time at which the Financial Workbook was created. */
    creationTime: string;
}

/** Models a list of Financial Workbooks. */
export class FinancialWorkbooksList implements IFinancialWorkbooksList {
    /** The set of Financial Workbooks being listed. */
    workbooks!: FinancialWorkbook[];

    constructor(data?: IFinancialWorkbooksList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workbooks = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["workbooks"])) {
                this.workbooks = [] as any;
                for (let item of _data["workbooks"])
                    this.workbooks!.push(FinancialWorkbook.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinancialWorkbooksList {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialWorkbooksList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.workbooks)) {
            data["workbooks"] = [];
            for (let item of this.workbooks)
                data["workbooks"].push(item.toJSON());
        }
        return data; 
    }

    clone(): FinancialWorkbooksList {
        const json = this.toJSON();
        let result = new FinancialWorkbooksList();
        result.init(json);
        return result;
    }
}

/** Models a list of Financial Workbooks. */
export interface IFinancialWorkbooksList {
    /** The set of Financial Workbooks being listed. */
    workbooks: FinancialWorkbook[];
}

/** This response may be used when returning a 403 HTTP status code. */
export class Forbidden implements IForbidden {
    /** A description of why the request was denied for troubleshooting purposes.
May be null or omitted. */
    description?: string | undefined;

    constructor(data?: IForbidden) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Forbidden {
        data = typeof data === 'object' ? data : {};
        let result = new Forbidden();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data; 
    }

    clone(): Forbidden {
        const json = this.toJSON();
        let result = new Forbidden();
        result.init(json);
        return result;
    }
}

/** This response may be used when returning a 403 HTTP status code. */
export interface IForbidden {
    /** A description of why the request was denied for troubleshooting purposes.
May be null or omitted. */
    description?: string | undefined;
}

/** Models an identifier. */
export class Identifier implements IIdentifier {
    /** A label for the identifier to better understand its meaning. Possible values include, but are not limited to; ABN, ACN, TFN, EIN, WPN, ResaleNumber, SSN. */
    label!: string;
    /** The value for the identifier without any implied formatting or validation. */
    value!: string;

    constructor(data?: IIdentifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Identifier {
        data = typeof data === 'object' ? data : {};
        let result = new Identifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): Identifier {
        const json = this.toJSON();
        let result = new Identifier();
        result.init(json);
        return result;
    }
}

/** Models an identifier. */
export interface IIdentifier {
    /** A label for the identifier to better understand its meaning. Possible values include, but are not limited to; ABN, ACN, TFN, EIN, WPN, ResaleNumber, SSN. */
    label: string;
    /** The value for the identifier without any implied formatting or validation. */
    value: string;
}

/** Models a request to schedule financial imports. */
export class ImportSchedule implements IImportSchedule {
    /** An identifier for the dataset from which the financial data will be imported. Unique within the scope of the datasource. */
    datasetId!: string;
    /** An identifier for the Accounting System or other datasource from which the financial data will be imported. */
    datasourceNameId!: string;
    recurrenceOptions?: RecurrenceOptions;
    /** The name of the timezone used for scheduling as defined by the IANA TZ database. */
    timeZoneName?: string | undefined;

    constructor(data?: IImportSchedule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.datasetId = _data["datasetId"];
            this.datasourceNameId = _data["datasourceNameId"];
            this.recurrenceOptions = _data["recurrenceOptions"] ? RecurrenceOptions.fromJS(_data["recurrenceOptions"]) : <any>undefined;
            this.timeZoneName = _data["timeZoneName"];
        }
    }

    static fromJS(data: any): ImportSchedule {
        data = typeof data === 'object' ? data : {};
        let result = new ImportSchedule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["datasetId"] = this.datasetId;
        data["datasourceNameId"] = this.datasourceNameId;
        data["recurrenceOptions"] = this.recurrenceOptions ? this.recurrenceOptions.toJSON() : <any>undefined;
        data["timeZoneName"] = this.timeZoneName;
        return data; 
    }

    clone(): ImportSchedule {
        const json = this.toJSON();
        let result = new ImportSchedule();
        result.init(json);
        return result;
    }
}

/** Models a request to schedule financial imports. */
export interface IImportSchedule {
    /** An identifier for the dataset from which the financial data will be imported. Unique within the scope of the datasource. */
    datasetId: string;
    /** An identifier for the Accounting System or other datasource from which the financial data will be imported. */
    datasourceNameId: string;
    recurrenceOptions?: RecurrenceOptions;
    /** The name of the timezone used for scheduling as defined by the IANA TZ database. */
    timeZoneName?: string | undefined;
}

/** Models parameters to setup an Organization as it appears in the Strongbox Web Portal. */
export class InitializeOrganizationParameters implements IInitializeOrganizationParameters {
    /** A display name to be used for the Organization as it appears in the Strongbox Web Portal.
The maximum length of the display name is 256 characters. */
    displayName!: string;

    constructor(data?: IInitializeOrganizationParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): InitializeOrganizationParameters {
        data = typeof data === 'object' ? data : {};
        let result = new InitializeOrganizationParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): InitializeOrganizationParameters {
        const json = this.toJSON();
        let result = new InitializeOrganizationParameters();
        result.init(json);
        return result;
    }
}

/** Models parameters to setup an Organization as it appears in the Strongbox Web Portal. */
export interface IInitializeOrganizationParameters {
    /** A display name to be used for the Organization as it appears in the Strongbox Web Portal.
The maximum length of the display name is 256 characters. */
    displayName: string;
}

/** Constants used to specify either the receivables or payables invoicing module. |Enum Value|Description| |--|--| |Receivables|The receivable transactions module.| |Payables|The payable transactions module.| */
export type InvoicingModule = "Receivables" | "Payables";

/** Models a line item appearing in a financial statement. */
export class LineItem implements ILineItem {
    accountRef?: AccountReference;
    /** A label for for the line item. For example, "Assets", "Total Current Assets", "Gross Profit", or "Accounts Receivable". */
    caption!: string;
    /** The reported monetary amounts associated with the line item. These figures correspond to the reporting periods in the financial statement column headers. If the type of line item is None, then there will be no column data. */
    columnData!: number[];
    /** An optional description of the line item. Can be presented as tooltip depending on the mechanism being used to present the financial statement. May be null. */
    description?: string | undefined;
    /** A 6-digit hex code defining the fill color to use for the line item. For example, "#000000" */
    fillColorHexCode?: string | undefined;
    /** An identifier for the line item which is unique within the scope of the financial statement. */
    id!: string;
    /** For presentation purposes, this represents the indentation level of the line item. */
    indentationLevel!: number;
    styles!: LineItemStyleFlags;

    constructor(data?: ILineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.columnData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountRef = _data["accountRef"] ? AccountReference.fromJS(_data["accountRef"]) : <any>undefined;
            this.caption = _data["caption"];
            if (Array.isArray(_data["columnData"])) {
                this.columnData = [] as any;
                for (let item of _data["columnData"])
                    this.columnData!.push(item);
            }
            this.description = _data["description"];
            this.fillColorHexCode = _data["fillColorHexCode"];
            this.id = _data["id"];
            this.indentationLevel = _data["indentationLevel"];
            this.styles = _data["styles"];
        }
    }

    static fromJS(data: any): LineItem {
        data = typeof data === 'object' ? data : {};
        let result = new LineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountRef"] = this.accountRef ? this.accountRef.toJSON() : <any>undefined;
        data["caption"] = this.caption;
        if (Array.isArray(this.columnData)) {
            data["columnData"] = [];
            for (let item of this.columnData)
                data["columnData"].push(item);
        }
        data["description"] = this.description;
        data["fillColorHexCode"] = this.fillColorHexCode;
        data["id"] = this.id;
        data["indentationLevel"] = this.indentationLevel;
        data["styles"] = this.styles;
        return data; 
    }

    clone(): LineItem {
        const json = this.toJSON();
        let result = new LineItem();
        result.init(json);
        return result;
    }
}

/** Models a line item appearing in a financial statement. */
export interface ILineItem {
    accountRef?: AccountReference;
    /** A label for for the line item. For example, "Assets", "Total Current Assets", "Gross Profit", or "Accounts Receivable". */
    caption: string;
    /** The reported monetary amounts associated with the line item. These figures correspond to the reporting periods in the financial statement column headers. If the type of line item is None, then there will be no column data. */
    columnData: number[];
    /** An optional description of the line item. Can be presented as tooltip depending on the mechanism being used to present the financial statement. May be null. */
    description?: string | undefined;
    /** A 6-digit hex code defining the fill color to use for the line item. For example, "#000000" */
    fillColorHexCode?: string | undefined;
    /** An identifier for the line item which is unique within the scope of the financial statement. */
    id: string;
    /** For presentation purposes, this represents the indentation level of the line item. */
    indentationLevel: number;
    styles: LineItemStyleFlags;
}

/** Specifies styles for line items that can appear in a financial statement. These flags are JSON serialized as a comma delimited list. For example, "DoubleOverscore, Bold". */
export type LineItemStyleFlags = "None" | "SingleOverscore" | "DoubleOverscore" | "Bold" | "Italic";

/** This response may be used when returning a 404 HTTP status code. */
export class NotFound implements INotFound {
    /** A message describing which resouce could not be found for troubleshooting purposes. */
    description?: string | undefined;

    constructor(data?: INotFound) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): NotFound {
        data = typeof data === 'object' ? data : {};
        let result = new NotFound();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data; 
    }

    clone(): NotFound {
        const json = this.toJSON();
        let result = new NotFound();
        result.init(json);
        return result;
    }
}

/** This response may be used when returning a 404 HTTP status code. */
export interface INotFound {
    /** A message describing which resouce could not be found for troubleshooting purposes. */
    description?: string | undefined;
}

/** Models the name of an organization. */
export class OrganizationName implements IOrganizationName {
    /** A set of tags providing additional information about the name. */
    tags!: OrganizationNameTag[];
    /** The name value with no implied formatting or validation. */
    value!: string;

    constructor(data?: IOrganizationName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): OrganizationName {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["value"] = this.value;
        return data; 
    }

    clone(): OrganizationName {
        const json = this.toJSON();
        let result = new OrganizationName();
        result.init(json);
        return result;
    }
}

/** Models the name of an organization. */
export interface IOrganizationName {
    /** A set of tags providing additional information about the name. */
    tags: OrganizationNameTag[];
    /** The name value with no implied formatting or validation. */
    value: string;
}

/** Defines a set of tags providing additional information about a Name. |Enum Value|Description| |--|--| |Legal|The name is the legal name for the Organization.| |Dba|The name is used as a trade name. Short for "Doing Business As".| */
export type OrganizationNameTag = "Legal" | "Dba";

/** Models additional contact information. */
export class OtherContactMethod implements IOtherContactMethod {
    /** A name or description of the contact associated with the contact info. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** A friendly description of the contact method. For example 'Skype Account'. */
    description!: string;
    /** A value for the contact method without any implied formatting or validation. */
    value!: string;

    constructor(data?: IOtherContactMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contact = _data["contact"];
            this.description = _data["description"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): OtherContactMethod {
        data = typeof data === 'object' ? data : {};
        let result = new OtherContactMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact;
        data["description"] = this.description;
        data["value"] = this.value;
        return data; 
    }

    clone(): OtherContactMethod {
        const json = this.toJSON();
        let result = new OtherContactMethod();
        result.init(json);
        return result;
    }
}

/** Models additional contact information. */
export interface IOtherContactMethod {
    /** A name or description of the contact associated with the contact info. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** A friendly description of the contact method. For example 'Skype Account'. */
    description: string;
    /** A value for the contact method without any implied formatting or validation. */
    value: string;
}

/** Models a set of payable transactions. */
export class PayablesList implements IPayablesList {
    /** The date corresponding to the information about the payable transactions. */
    asOf!: string;
    /** The set of receivable or payable transactions. */
    transactions!: ReceivableOrPayable[];

    constructor(data?: IPayablesList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.transactions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.asOf = _data["asOf"];
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(ReceivableOrPayable.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PayablesList {
        data = typeof data === 'object' ? data : {};
        let result = new PayablesList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["asOf"] = this.asOf;
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PayablesList {
        const json = this.toJSON();
        let result = new PayablesList();
        result.init(json);
        return result;
    }
}

/** Models a set of payable transactions. */
export interface IPayablesList {
    /** The date corresponding to the information about the payable transactions. */
    asOf: string;
    /** The set of receivable or payable transactions. */
    transactions: ReceivableOrPayable[];
}

/** Models a phone number. */
export class PhoneNumber implements IPhoneNumber {
    /** Specific components of the phone number that have been identified. The set of Components do not necessarily provide a complete representation of the phone number. */
    components!: PhoneNumberComponent[];
    /** A name or description of the contact associated with the phone number. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** A set of tags for the phone intended to provide accessory information about it. */
    tags!: PhoneNumberTags[];
    /** A complete representation of the phone number without any implied formatting or validation. */
    value!: string;

    constructor(data?: IPhoneNumber) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.components = [];
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["components"])) {
                this.components = [] as any;
                for (let item of _data["components"])
                    this.components!.push(PhoneNumberComponent.fromJS(item));
            }
            this.contact = _data["contact"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item.toJSON());
        }
        data["contact"] = this.contact;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["value"] = this.value;
        return data; 
    }

    clone(): PhoneNumber {
        const json = this.toJSON();
        let result = new PhoneNumber();
        result.init(json);
        return result;
    }
}

/** Models a phone number. */
export interface IPhoneNumber {
    /** Specific components of the phone number that have been identified. The set of Components do not necessarily provide a complete representation of the phone number. */
    components: PhoneNumberComponent[];
    /** A name or description of the contact associated with the phone number. For example, "John Doe" or "Customer Support". */
    contact?: string | undefined;
    /** A set of tags for the phone intended to provide accessory information about it. */
    tags: PhoneNumberTags[];
    /** A complete representation of the phone number without any implied formatting or validation. */
    value: string;
}

/** Models the part of a phone number that has been identified. */
export class PhoneNumberComponent implements IPhoneNumberComponent {
    type!: ComponentOfPhoneNumber;
    /** The value of the part of the phone number that has been identified with no implied formatting. */
    value!: string;

    constructor(data?: IPhoneNumberComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PhoneNumberComponent {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumberComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data; 
    }

    clone(): PhoneNumberComponent {
        const json = this.toJSON();
        let result = new PhoneNumberComponent();
        result.init(json);
        return result;
    }
}

/** Models the part of a phone number that has been identified. */
export interface IPhoneNumberComponent {
    type: ComponentOfPhoneNumber;
    /** The value of the part of the phone number that has been identified with no implied formatting. */
    value: string;
}

/** Defines a set of tags providing additional information about a phone number. |Enum Value|Description| |--|--| |Cellular|The phone number is for a cell phone.| |Landline|The phone number is a land line.| |Fax|The phone number is for fax.| |Pager|The phone number is for a pager.| |Support|The phone number is a customer support number.| |Person|The phone number is associated with a person.| |Organization|The phone number is associated with an organization.| */
export type PhoneNumberTags = "Cellular" | "Landline" | "Fax" | "Pager" | "Support" | "Person" | "Organization";

/** Defines the set of privacy controls that can be applied to imported financial data. |Enum Value|Description| |--|--| |AnonymizeContactLists|Customer and vendor lists are anonymized.| |RedactTransactionMemos|Memos/narrations associated with transactions are redacted as they may contain sensitive information.| */
export type PrivacyControl = "AnonymizeContactLists" | "RedactTransactionMemos";

/** Models a receivable or payable transaction including invoices, payments, and credit notes. */
export class ReceivableOrPayable implements IReceivableOrPayable {
    amountOutstanding!: DoubleEntryAmount;
    businessRelationship?: BusinessRelationship;
    /** A positive or negative integer representing the number of days before or after the due date relative to the financial reporting date. For example, the age one day before the due date is -1 and the age one day after the due date is 1. If a due date is not specified then 'transactionDate' is treated as the due date. */
    daysFromDueDate!: number;
    /** A positive integer representing the number of days since the transaction was created as of the financial reporting date. For example, the age one day after the transaction date is 1. */
    daysFromTransactionDate!: number;
    debtType!: DebtType;
    /** The date at which time an invoice is due, if a due date is specified. */
    dueDate?: string | undefined;
    transactionAmount!: DoubleEntryAmount;
    /** The date on which the transaction occured, for financial reporting purposes. */
    transactionDate!: string;
    /** An identifier for the transaction. */
    transactionId!: string;
    /** The type of the transaction, as specified by the datasource. Some examples are: "Invoice", "Credit Memo", and "Credit Card Payment". */
    transactionType?: string | undefined;
    /** A human friendly identifier for the receivable or payable transaction if specified (may be null). This is often user-defined and may contain alphabetic characters. Examples are 'Invoice #' and 'Credit Memo #' found in QuickBooks or Xero. */
    userReferenceNumber?: string | undefined;

    constructor(data?: IReceivableOrPayable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.amountOutstanding = new DoubleEntryAmount();
            this.transactionAmount = new DoubleEntryAmount();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amountOutstanding = _data["amountOutstanding"] ? DoubleEntryAmount.fromJS(_data["amountOutstanding"]) : new DoubleEntryAmount();
            this.businessRelationship = _data["businessRelationship"] ? BusinessRelationship.fromJS(_data["businessRelationship"]) : <any>undefined;
            this.daysFromDueDate = _data["daysFromDueDate"];
            this.daysFromTransactionDate = _data["daysFromTransactionDate"];
            this.debtType = _data["debtType"];
            this.dueDate = _data["dueDate"];
            this.transactionAmount = _data["transactionAmount"] ? DoubleEntryAmount.fromJS(_data["transactionAmount"]) : new DoubleEntryAmount();
            this.transactionDate = _data["transactionDate"];
            this.transactionId = _data["transactionId"];
            this.transactionType = _data["transactionType"];
            this.userReferenceNumber = _data["userReferenceNumber"];
        }
    }

    static fromJS(data: any): ReceivableOrPayable {
        data = typeof data === 'object' ? data : {};
        let result = new ReceivableOrPayable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountOutstanding"] = this.amountOutstanding ? this.amountOutstanding.toJSON() : <any>undefined;
        data["businessRelationship"] = this.businessRelationship ? this.businessRelationship.toJSON() : <any>undefined;
        data["daysFromDueDate"] = this.daysFromDueDate;
        data["daysFromTransactionDate"] = this.daysFromTransactionDate;
        data["debtType"] = this.debtType;
        data["dueDate"] = this.dueDate;
        data["transactionAmount"] = this.transactionAmount ? this.transactionAmount.toJSON() : <any>undefined;
        data["transactionDate"] = this.transactionDate;
        data["transactionId"] = this.transactionId;
        data["transactionType"] = this.transactionType;
        data["userReferenceNumber"] = this.userReferenceNumber;
        return data; 
    }

    clone(): ReceivableOrPayable {
        const json = this.toJSON();
        let result = new ReceivableOrPayable();
        result.init(json);
        return result;
    }
}

/** Models a receivable or payable transaction including invoices, payments, and credit notes. */
export interface IReceivableOrPayable {
    amountOutstanding: DoubleEntryAmount;
    businessRelationship?: BusinessRelationship;
    /** A positive or negative integer representing the number of days before or after the due date relative to the financial reporting date. For example, the age one day before the due date is -1 and the age one day after the due date is 1. If a due date is not specified then 'transactionDate' is treated as the due date. */
    daysFromDueDate: number;
    /** A positive integer representing the number of days since the transaction was created as of the financial reporting date. For example, the age one day after the transaction date is 1. */
    daysFromTransactionDate: number;
    debtType: DebtType;
    /** The date at which time an invoice is due, if a due date is specified. */
    dueDate?: string | undefined;
    transactionAmount: DoubleEntryAmount;
    /** The date on which the transaction occured, for financial reporting purposes. */
    transactionDate: string;
    /** An identifier for the transaction. */
    transactionId: string;
    /** The type of the transaction, as specified by the datasource. Some examples are: "Invoice", "Credit Memo", and "Credit Card Payment". */
    transactionType?: string | undefined;
    /** A human friendly identifier for the receivable or payable transaction if specified (may be null). This is often user-defined and may contain alphabetic characters. Examples are 'Invoice #' and 'Credit Memo #' found in QuickBooks or Xero. */
    userReferenceNumber?: string | undefined;
}

/** Models a set of receivable transactions. */
export class ReceivablesList implements IReceivablesList {
    /** The date corresponding to the information about the payable transactions. */
    asOf!: string;
    /** The set of receivable or payable transactions. */
    transactions!: ReceivableOrPayable[];

    constructor(data?: IReceivablesList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.transactions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.asOf = _data["asOf"];
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(ReceivableOrPayable.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReceivablesList {
        data = typeof data === 'object' ? data : {};
        let result = new ReceivablesList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["asOf"] = this.asOf;
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ReceivablesList {
        const json = this.toJSON();
        let result = new ReceivablesList();
        result.init(json);
        return result;
    }
}

/** Models a set of receivable transactions. */
export interface IReceivablesList {
    /** The date corresponding to the information about the payable transactions. */
    asOf: string;
    /** The set of receivable or payable transactions. */
    transactions: ReceivableOrPayable[];
}

/** Models options to setup a recurring schedule. */
export class RecurrenceOptions implements IRecurrenceOptions {
    /** A positive or negative number representing a number of days from the beginning of the week or month. For example, this allows scheduling to be done on a specific day of the week or on the first or last day of the month. Weeks are considered to start on Sunday for scheduling purposes. */
    offsetByDays?: number;
    /** A positive integer used to specify the number of weeks or months between scheduled imports. The default if not specified is 1. */
    period?: number;
    timeUnit?: SchedulingUnitOfTime;

    constructor(data?: IRecurrenceOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offsetByDays = _data["offsetByDays"];
            this.period = _data["period"];
            this.timeUnit = _data["timeUnit"];
        }
    }

    static fromJS(data: any): RecurrenceOptions {
        data = typeof data === 'object' ? data : {};
        let result = new RecurrenceOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["offsetByDays"] = this.offsetByDays;
        data["period"] = this.period;
        data["timeUnit"] = this.timeUnit;
        return data; 
    }

    clone(): RecurrenceOptions {
        const json = this.toJSON();
        let result = new RecurrenceOptions();
        result.init(json);
        return result;
    }
}

/** Models options to setup a recurring schedule. */
export interface IRecurrenceOptions {
    /** A positive or negative number representing a number of days from the beginning of the week or month. For example, this allows scheduling to be done on a specific day of the week or on the first or last day of the month. Weeks are considered to start on Sunday for scheduling purposes. */
    offsetByDays?: number;
    /** A positive integer used to specify the number of weeks or months between scheduled imports. The default if not specified is 1. */
    period?: number;
    timeUnit?: SchedulingUnitOfTime;
}

/** Models account totals for a specific reporting period. */
export class ReportedTotals implements IReportedTotals {
    /** The last day for the reporting period (inclusive). */
    fromDate!: string;
    /** The first day of the reporting period (inclusive). */
    toDate!: string;
    /** Lists the totals for each account for the given reporting period. */
    totalsByAccount!: AccountSummary[];

    constructor(data?: IReportedTotals) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.totalsByAccount = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            if (Array.isArray(_data["totalsByAccount"])) {
                this.totalsByAccount = [] as any;
                for (let item of _data["totalsByAccount"])
                    this.totalsByAccount!.push(AccountSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportedTotals {
        data = typeof data === 'object' ? data : {};
        let result = new ReportedTotals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        if (Array.isArray(this.totalsByAccount)) {
            data["totalsByAccount"] = [];
            for (let item of this.totalsByAccount)
                data["totalsByAccount"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ReportedTotals {
        const json = this.toJSON();
        let result = new ReportedTotals();
        result.init(json);
        return result;
    }
}

/** Models account totals for a specific reporting period. */
export interface IReportedTotals {
    /** The last day for the reporting period (inclusive). */
    fromDate: string;
    /** The first day of the reporting period (inclusive). */
    toDate: string;
    /** Lists the totals for each account for the given reporting period. */
    totalsByAccount: AccountSummary[];
}

/** Specifies the time period for which accounting and other financial data is prepared. |Enum Value|Description| |--|--| |Months|The reporting period is monthly.| |FiscalQuarters|The reporting period is quarterly; aligned to the fiscal year for the accounting entity.| |FiscalYears|The reporting period is annual; aligned to the fiscal year for the accounting entity.| */
export type ReportingPeriod = "Months" | "FiscalQuarters" | "FiscalYears";

/** Specifies a unit of time for scheduling. |Enum Value|Description| |--|--| |Weeks|The unit of time is weeks. Weeks are considered to start Sunday for scheduling purposes.| |Months|The unit of time is months.| */
export type SchedulingUnitOfTime = "Weeks" | "Months";

/** Models an accounting transaction. */
export class Transaction implements ITransaction {
    /** The set of account entries that make up the transaction. */
    entries!: TransactionEntry[];
    /** A unique identifier for this transaction within the scope of the Dataset. */
    id!: string;
    /** The date on which the transaction occurred for financial reporting purposes. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    reportingDate!: string;
    /** The type of transaction as labeled by the source accounting system. May be null or empty. */
    type?: string | undefined;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(TransactionEntry.fromJS(item));
            }
            this.id = _data["id"];
            this.reportingDate = _data["reportingDate"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["reportingDate"] = this.reportingDate;
        data["type"] = this.type;
        return data; 
    }

    clone(): Transaction {
        const json = this.toJSON();
        let result = new Transaction();
        result.init(json);
        return result;
    }
}

/** Models an accounting transaction. */
export interface ITransaction {
    /** The set of account entries that make up the transaction. */
    entries: TransactionEntry[];
    /** A unique identifier for this transaction within the scope of the Dataset. */
    id: string;
    /** The date on which the transaction occurred for financial reporting purposes. This date is serialized to a string using the "YYYY-MM-DD" format as defined by ISO 8601-1:2019. */
    reportingDate: string;
    /** The type of transaction as labeled by the source accounting system. May be null or empty. */
    type?: string | undefined;
}

/** Models additional accounting dimensions such as Business Relations, Products/Services, QuickBooks 'Classes', and Xero 'Tracking Categories' that can be associated with transactional data entries. */
export class TransactionDimension implements ITransactionDimension {
    /** An identifier for the transaction dimension. */
    id!: string;
    /** A label for the transaction dimension. For example, 'Department'. */
    label!: string;

    constructor(data?: ITransactionDimension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): TransactionDimension {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDimension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        return data; 
    }

    clone(): TransactionDimension {
        const json = this.toJSON();
        let result = new TransactionDimension();
        result.init(json);
        return result;
    }
}

/** Models additional accounting dimensions such as Business Relations, Products/Services, QuickBooks 'Classes', and Xero 'Tracking Categories' that can be associated with transactional data entries. */
export interface ITransactionDimension {
    /** An identifier for the transaction dimension. */
    id: string;
    /** A label for the transaction dimension. For example, 'Department'. */
    label: string;
}

/** Models the value of a transaction dimension that was assigned to an individual transactional data entry. */
export class TransactionDimensionTag implements ITransactionDimensionTag {
    /** An identifier for dimension associated with this tag. */
    dimensionId!: string;
    /** An identifier for the dimension tag. */
    id?: string | undefined;
    /** A label for the dimension tag. */
    label?: string | undefined;

    constructor(data?: ITransactionDimensionTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dimensionId = _data["dimensionId"];
            this.id = _data["id"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): TransactionDimensionTag {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDimensionTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dimensionId"] = this.dimensionId;
        data["id"] = this.id;
        data["label"] = this.label;
        return data; 
    }

    clone(): TransactionDimensionTag {
        const json = this.toJSON();
        let result = new TransactionDimensionTag();
        result.init(json);
        return result;
    }
}

/** Models the value of a transaction dimension that was assigned to an individual transactional data entry. */
export interface ITransactionDimensionTag {
    /** An identifier for dimension associated with this tag. */
    dimensionId: string;
    /** An identifier for the dimension tag. */
    id?: string | undefined;
    /** A label for the dimension tag. */
    label?: string | undefined;
}

/** A transaction entry. */
export class TransactionEntry implements ITransactionEntry {
    /** Values for any additional dimensions for the transaction entry that may be available depending on the accounting system and organization. */
    dimensionTags!: TransactionDimensionTag[];
    /** An identifier for the account affected by this transaction entry. */
    accountId!: string;
    entry!: DoubleEntryAmount;
    /** An optional memorandum for the entry. May be null or empty. */
    memo?: string | undefined;
    /** Defines an ordering for the transaction entry and may be used as an identifier that is unique within the scope of the transaction. Please be aware that this does not necessarily correspond to the visual ordering of the entry as it would appear in the accounting system. */
    number!: number;

    constructor(data?: ITransactionEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dimensionTags = [];
            this.entry = new DoubleEntryAmount();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dimensionTags"])) {
                this.dimensionTags = [] as any;
                for (let item of _data["dimensionTags"])
                    this.dimensionTags!.push(TransactionDimensionTag.fromJS(item));
            }
            this.accountId = _data["accountId"];
            this.entry = _data["entry"] ? DoubleEntryAmount.fromJS(_data["entry"]) : new DoubleEntryAmount();
            this.memo = _data["memo"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): TransactionEntry {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dimensionTags)) {
            data["dimensionTags"] = [];
            for (let item of this.dimensionTags)
                data["dimensionTags"].push(item.toJSON());
        }
        data["accountId"] = this.accountId;
        data["entry"] = this.entry ? this.entry.toJSON() : <any>undefined;
        data["memo"] = this.memo;
        data["number"] = this.number;
        return data; 
    }

    clone(): TransactionEntry {
        const json = this.toJSON();
        let result = new TransactionEntry();
        result.init(json);
        return result;
    }
}

/** A transaction entry. */
export interface ITransactionEntry {
    /** Values for any additional dimensions for the transaction entry that may be available depending on the accounting system and organization. */
    dimensionTags: TransactionDimensionTag[];
    /** An identifier for the account affected by this transaction entry. */
    accountId: string;
    entry: DoubleEntryAmount;
    /** An optional memorandum for the entry. May be null or empty. */
    memo?: string | undefined;
    /** Defines an ordering for the transaction entry and may be used as an identifier that is unique within the scope of the transaction. Please be aware that this does not necessarily correspond to the visual ordering of the entry as it would appear in the accounting system. */
    number: number;
}

/** Used to configure the transactional data that is collected from the accounting system. */
export class TransactionImportOptions implements ITransactionImportOptions {
    reportingPeriod?: ReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods!: number;

    constructor(data?: ITransactionImportOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportingPeriod = _data["reportingPeriod"];
            this.numberOfPeriods = _data["numberOfPeriods"];
        }
    }

    static fromJS(data: any): TransactionImportOptions {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionImportOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportingPeriod"] = this.reportingPeriod;
        data["numberOfPeriods"] = this.numberOfPeriods;
        return data; 
    }

    clone(): TransactionImportOptions {
        const json = this.toJSON();
        let result = new TransactionImportOptions();
        result.init(json);
        return result;
    }
}

/** Used to configure the transactional data that is collected from the accounting system. */
export interface ITransactionImportOptions {
    reportingPeriod?: ReportingPeriod;
    /** A natural number greater than or equal to zero used to specify the total number of months, quarters, or years for which financial data is desired. The month-to-date, quarter-to-date, or year-to-date period is included in this count. For example, setting 'reportingPeriod' to 'FiscalYears' and 'numberOfReportingPeriods' to 3 should be interpreted as '2 full fiscal years and fiscal YTD'. Setting 'numberOfPeriods' to zero disables data collection. */
    numberOfPeriods: number;
}

/** Models the complete set of accounting transactions for a given time period. */
export class TransactionList implements ITransactionList {
    /** A list of the dimensions that are available as part of the transactional data. The set of dimensions may vary by accounting system and even by each organization.
<br></br>
Examples of dimensions are Business Relations, Products/Services, QuickBooks 'Classes', and Xero 'Tracking Categories'. */
    dimensions!: TransactionDimension[];
    /** Transactions on or after this date are included. */
    fromDate!: string;
    /** Transactions on or before this date are included. */
    toDate!: string;
    /** The complete set of accounting transactions for the specified time period. */
    transactions!: Transaction[];

    constructor(data?: ITransactionList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dimensions = [];
            this.transactions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dimensions"])) {
                this.dimensions = [] as any;
                for (let item of _data["dimensions"])
                    this.dimensions!.push(TransactionDimension.fromJS(item));
            }
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(Transaction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionList {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dimensions)) {
            data["dimensions"] = [];
            for (let item of this.dimensions)
                data["dimensions"].push(item.toJSON());
        }
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TransactionList {
        const json = this.toJSON();
        let result = new TransactionList();
        result.init(json);
        return result;
    }
}

/** Models the complete set of accounting transactions for a given time period. */
export interface ITransactionList {
    /** A list of the dimensions that are available as part of the transactional data. The set of dimensions may vary by accounting system and even by each organization.
<br></br>
Examples of dimensions are Business Relations, Products/Services, QuickBooks 'Classes', and Xero 'Tracking Categories'. */
    dimensions: TransactionDimension[];
    /** Transactions on or after this date are included. */
    fromDate: string;
    /** Transactions on or before this date are included. */
    toDate: string;
    /** The complete set of accounting transactions for the specified time period. */
    transactions: Transaction[];
}

/** Models a Webhook Endpoint that will be invoked whenever a configured event occurs within the Strongbox Platform. */
export class WebhookEndpoint implements IWebhookEndpoint {
    /** The time at which the webhook was created. */
    creationTime!: string;
    /** The set of events for which the webhook will be invoked. */
    eventTypes!: string[];
    /** An identifier for the Webhook Endpoint. */
    id!: string;
    /** A secret used in combination with HMAC SHA256 to sign requests that are sent to the webhook endpoint. */
    sharedSecret!: string;
    /** The absolute URL to the endpoint that will be called. The URL must use the `https` scheme. */
    url!: string;

    constructor(data?: IWebhookEndpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.eventTypes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationTime = _data["creationTime"];
            if (Array.isArray(_data["eventTypes"])) {
                this.eventTypes = [] as any;
                for (let item of _data["eventTypes"])
                    this.eventTypes!.push(item);
            }
            this.id = _data["id"];
            this.sharedSecret = _data["sharedSecret"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): WebhookEndpoint {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEndpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime;
        if (Array.isArray(this.eventTypes)) {
            data["eventTypes"] = [];
            for (let item of this.eventTypes)
                data["eventTypes"].push(item);
        }
        data["id"] = this.id;
        data["sharedSecret"] = this.sharedSecret;
        data["url"] = this.url;
        return data; 
    }

    clone(): WebhookEndpoint {
        const json = this.toJSON();
        let result = new WebhookEndpoint();
        result.init(json);
        return result;
    }
}

/** Models a Webhook Endpoint that will be invoked whenever a configured event occurs within the Strongbox Platform. */
export interface IWebhookEndpoint {
    /** The time at which the webhook was created. */
    creationTime: string;
    /** The set of events for which the webhook will be invoked. */
    eventTypes: string[];
    /** An identifier for the Webhook Endpoint. */
    id: string;
    /** A secret used in combination with HMAC SHA256 to sign requests that are sent to the webhook endpoint. */
    sharedSecret: string;
    /** The absolute URL to the endpoint that will be called. The URL must use the `https` scheme. */
    url: string;
}

/** Models a list of Webhook Endpoints. */
export class WebhookEndpointList implements IWebhookEndpointList {
    /** The list of Webhook Endpoints. */
    webhookEndpoints!: WebhookEndpoint[];

    constructor(data?: IWebhookEndpointList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.webhookEndpoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["webhookEndpoints"])) {
                this.webhookEndpoints = [] as any;
                for (let item of _data["webhookEndpoints"])
                    this.webhookEndpoints!.push(WebhookEndpoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WebhookEndpointList {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEndpointList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.webhookEndpoints)) {
            data["webhookEndpoints"] = [];
            for (let item of this.webhookEndpoints)
                data["webhookEndpoints"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WebhookEndpointList {
        const json = this.toJSON();
        let result = new WebhookEndpointList();
        result.init(json);
        return result;
    }
}

/** Models a list of Webhook Endpoints. */
export interface IWebhookEndpointList {
    /** The list of Webhook Endpoints. */
    webhookEndpoints: WebhookEndpoint[];
}

/** Models a webhook endpoint that will be invoked whenever a configured event occurs within the Strongbox Platform. */
export class WebhookEndpointParameters implements IWebhookEndpointParameters {
    /** The set of events for which the webhook will be invoked. */
    events!: string[];
    /** The absolute URL to the endpoint that will be called. The URL must use the `https` scheme. */
    url!: string;

    constructor(data?: IWebhookEndpointParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.events = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(item);
            }
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): WebhookEndpointParameters {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEndpointParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item);
        }
        data["url"] = this.url;
        return data; 
    }

    clone(): WebhookEndpointParameters {
        const json = this.toJSON();
        let result = new WebhookEndpointParameters();
        result.init(json);
        return result;
    }
}

/** Models a webhook endpoint that will be invoked whenever a configured event occurs within the Strongbox Platform. */
export interface IWebhookEndpointParameters {
    /** The set of events for which the webhook will be invoked. */
    events: string[];
    /** The absolute URL to the endpoint that will be called. The URL must use the `https` scheme. */
    url: string;
}

/** Models information about a website. */
export class Website implements IWebsite {
    /** The URL of the website without any implied formatting or validation. */
    url!: string;

    constructor(data?: IWebsite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Website {
        data = typeof data === 'object' ? data : {};
        let result = new Website();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data; 
    }

    clone(): Website {
        const json = this.toJSON();
        let result = new Website();
        result.init(json);
        return result;
    }
}

/** Models information about a website. */
export interface IWebsite {
    /** The URL of the website without any implied formatting or validation. */
    url: string;
}

/** Represents the end of a fiscal, tax, or other year used for reporting. */
export class YearEnd implements IYearEnd {
    /** A number between 1-12 representing the month considered to be the end of the year for reporting purposes. */
    month!: number;

    constructor(data?: IYearEnd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
        }
    }

    static fromJS(data: any): YearEnd {
        data = typeof data === 'object' ? data : {};
        let result = new YearEnd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        return data; 
    }

    clone(): YearEnd {
        const json = this.toJSON();
        let result = new YearEnd();
        result.init(json);
        return result;
    }
}

/** Represents the end of a fiscal, tax, or other year used for reporting. */
export interface IYearEnd {
    /** A number between 1-12 representing the month considered to be the end of the year for reporting purposes. */
    month: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}